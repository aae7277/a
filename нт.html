<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Косынка Пасьянс (Ultimate Edition 2.0)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Roboto:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --card-width: min(12.5vw, 75px);
            --card-height: calc(var(--card-width) * 1.4);
            --gap: min(2vw, 15px);
            --orange: #f39c12;
            --orange-dark: #d35400;
            --green-dark: #013220;
            --green-light: #008000;
            --border-radius: 12px;
            --text-color: #fff;
            --panel-bg: rgba(0, 0, 0, 0.4);
            --font-main: 'Russo One', sans-serif;
            --font-body: 'Roboto', sans-serif;
        }
        body, html {
            font-family: var(--font-body);
            margin: 0;
            width: 100%;
            height: 100%;
            background-color: var(--green-dark);
            background-image: radial-gradient(farthest-corner at 50% 50%, var(--green-light) 0%, var(--green-dark) 100%);
            color: var(--text-color);
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            padding: var(--gap);
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            transform: scale(1.05);
        }
        .screen.active {
            display: flex;
            opacity: 1;
            transform: scale(1);
        }
        .main-btn {
            font-family: var(--font-main);
            font-size: min(5vw, 1.5em);
            background: linear-gradient(to bottom, var(--orange), var(--orange-dark));
            color: white;
            border: 2px solid #a04000;
            border-bottom-width: 5px;
            border-radius: var(--border-radius);
            padding: 15px 40px;
            margin: 10px 0;
            box-shadow: inset 0 2px 2px rgba(255,255,255,0.4);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 280px;
            transition: all 0.1s ease;
        }
        .main-btn:active { transform: translateY(3px); border-bottom-width: 2px; }
        .main-btn svg { width: 1.2em; height: 1.2em; margin-right: 10px; fill: white; }
        .panel-title {
            background: var(--panel-bg);
            padding: 10px 30px;
            border-radius: var(--border-radius);
            font-family: var(--font-main);
            font-size: min(6vw, 2em);
            display: flex; align-items: center; gap: 15px;
            margin-bottom: 20px;
        }
        .panel-title svg { width: 1em; height: 1em; fill: var(--orange); }
        .panel-box {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 3px solid var(--orange);
            box-shadow: inset 0 0 15px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 450px;
            text-align: center;
        }
        #main-menu-screen .title {
            font-family: var(--font-main);
            font-size: min(12vw, 5em);
            color: var(--orange);
            text-shadow: 3px 3px 0 var(--orange-dark), 6px 6px 10px rgba(0,0,0,0.5);
            text-align: center;
            line-height: 1;
            margin-bottom: 40px;
        }
        .bottom-nav { position: absolute; bottom: 20px; display: flex; gap: 20px; }
        .bottom-nav .main-btn, #settings-screen .main-btn { width: 70px; height: 70px; min-width: 0; padding: 0; font-size: 2em; }
        #settings-screen .setting-row { display: flex; justify-content: space-around; align-items: center; margin: 15px 0; }
        .toggle-btn {
            background: linear-gradient(to bottom, #555, #333);
            border: 2px solid #222; border-bottom-width: 5px;
            width: 80px; height: 50px; font-size: 1.5em; color: #aaa;
            border-radius: var(--border-radius); font-family: var(--font-main);
            cursor: pointer;
        }
        .toggle-btn.active { background: linear-gradient(to bottom, var(--orange), var(--orange-dark)); color: white; border-color: #a04000; }
        .toggle-btn:active { transform: translateY(3px); border-bottom-width: 2px; }
        .card-back-selector { width: calc(var(--card-width) / 1.5); height: calc(var(--card-height) / 1.5); cursor: pointer; border: 3px solid transparent; border-radius: 5px; }
        .card-back-selector.active { border-color: var(--orange); }

        #stats-screen .panel-box { font-size: min(4vw, 1.2em); line-height: 2; }
        #achievements-screen .achievement { display: flex; align-items: center; background: #555; margin: 10px 0; padding: 5px 10px; border-radius: 8px; font-size: 0.9em; transition: all 0.3s; }
        #achievements-screen .achievement.unlocked { background: #777; box-shadow: 0 0 10px var(--orange); }
        #achievements-screen .achievement svg { width: 30px; height: 30px; fill: #aaa; margin-right: 15px; }
        #achievements-screen .achievement.unlocked svg { fill: var(--orange); }
        #achievements-screen .progress-bar { width: 100%; background: #333; height: 20px; border-radius: 10px; margin-top: 20px; overflow: hidden; }
        #achievements-screen .progress-fill { background: var(--orange); height: 100%; border-radius: 10px; width: 0%; transition: width 0.5s; }
        #game-screen { justify-content: flex-start; }
        .game-top-bar {
            width: 100%; max-width: 500px;
            background: var(--panel-bg);
            border-radius: 50px; padding: 5px 20px;
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: var(--gap); box-sizing: border-box;
        }
        .game-top-bar span { display: flex; align-items: center; gap: 8px; font-size: min(4.5vw, 1.2em); }
        .game-top-bar svg { width: 1.2em; height: 1.2em; fill: var(--orange); }
        #game-board { display: grid; grid-template-columns: repeat(7, 1fr); grid-template-rows: var(--card-height) auto; gap: var(--gap); width: 100%; max-width: 700px; position: relative; }
        #game-board .top-row { grid-column: 1 / 8; display: grid; grid-template-columns: repeat(7, 1fr); gap: var(--gap);}
        #game-board .bottom-row { grid-column: 1 / 8; display: grid; grid-template-columns: repeat(7, 1fr); gap: var(--gap);}
        .pile { width: var(--card-width); height: var(--card-height); position: relative; justify-self: center; }
        .tableau-pile { height: 100%; }
        .pile-placeholder {
            width: 100%; height: 100%;
            border: 2px solid rgba(0,0,0,0.4);
            border-radius: var(--border-radius);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            position: absolute;
        }
        .pile-placeholder.foundation::before { content: 'A'; position: absolute; top:50%; left: 50%; transform: translate(-50%, -50%); font-size: calc(var(--card-width) / 1.5); color: rgba(0,0,0,0.5); font-family: var(--font-main); }
        .card {
            width: var(--card-width); height: var(--card-height);
            border-radius: calc(var(--border-radius) / 2);
            background-color: white; border: 1px solid #bbb;
            cursor: pointer; position: absolute;
            box-shadow: 0 2px 3px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; align-items: center;
            padding: 5px; box-sizing: border-box;
            font-size: calc(var(--card-width) / 3.5);
            font-weight: 700; transition: transform 0.2s, box-shadow 0.2s, top 0.2s;
        }
        .card.face-down {
            background-color: #2980b9;
            background-image: linear-gradient(45deg, #3498db 25%, transparent 25%), linear-gradient(-45deg, #3498db 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #3498db 75%), linear-gradient(-45deg, transparent 75%, #3498db 75%);
            background-size: 20px 20px;
        }
        /* Новые стили для рубашек */
        .card.face-down.back-1 { background-color: #2980b9; background-image: linear-gradient(45deg, #3498db 25%, transparent 25%), linear-gradient(-45deg, #3498db 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #3498db 75%), linear-gradient(-45deg, transparent 75%, #3498db 75%); background-size: 20px 20px; }
        .card.face-down.back-2 { background-color: #c0392b; background-image: radial-gradient(circle, #e74c3c, #c0392b); }
        .card.face-down.back-3 { background-color: #2c3e50; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%2334495e' fill-opacity='1'%3E%3Cpath d='M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"); }
        .card.red { color: #c0392b; }
        .card.black { color: #2c3e50; }
        .card .suit-icon { width: 40%; height: 40%; margin-top: 5px; }
        .card.red .suit-icon { fill: #c0392b; }
        .card.black .suit-icon { fill: #2c3e50; }
        .card.selected { box-shadow: 0 0 0 4px var(--orange), 0 5px 15px rgba(0,0,0,0.3); transform: translateY(-5px); }
        .card.hint { animation: hint-pulse 1s infinite; }
        @keyframes hint-pulse { 0%, 100% { box-shadow: 0 0 0 4px var(--orange); } 50% { box-shadow: 0 0 0 8px var(--orange); } }
        .tableau-pile .card { margin-top: calc(var(--card-height) / 5); }
        .tableau-pile .card:first-child { margin-top: 0; }
        .game-bottom-bar {
            position: absolute; bottom: 0; left:0; right: 0;
            background: var(--panel-bg); padding: 10px 0;
            display: flex; justify-content: space-around;
        }
        .game-bottom-bar .icon-btn {
            background: none; border: none; cursor: pointer; position: relative;
        }
        .icon-btn svg { width: min(8vw, 40px); height: min(8vw, 40px); fill: var(--text-color); }
        .icon-btn .badge {
            position: absolute; bottom: -5px; right: -5px;
            background: var(--orange); color: white;
            border-radius: 50%; width: 20px; height: 20px; font-size: 12px;
            display: flex; align-items: center; justify-content: center;
            border: 1px solid white; font-weight: 700;
        }
        #animation-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1000;
        }
        .flying-card { transition: all var(--animation-duration) ease-in-out; }
        
        /* Стили для модального окна */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: var(--panel-bg);
            padding: 30px;
            border-radius: var(--border-radius);
            border: 3px solid var(--orange);
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 450px;
            text-align: center;
            position: relative;
            transform: scale(0.7);
            transition: transform 0.3s ease;
        }
        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }
        .modal-title {
            font-family: var(--font-main);
            font-size: 2em;
            color: var(--orange);
            margin-bottom: 20px;
        }
        .modal-body .main-btn { margin: 5px auto; min-width: 250px; }
        .modal-close-btn {
            position: absolute;
            top: 10px; right: 10px;
            background: var(--orange-dark);
            border: 2px solid var(--orange);
            color: white;
            width: 30px; height: 30px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            font-family: var(--font-main);
        }
    </style>
</head>
<body>
    <div id="app-container"></div>
    <div id="animation-layer"></div>
    <div id="modal" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close-btn" data-action="close-modal">X</button>
            <h2 class="modal-title"></h2>
            <div class="modal-body"></div>
        </div>
    </div>
    
    <svg style="display:none;">
        <symbol id="icon-play" viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z" /></symbol>
        <symbol id="icon-settings" viewBox="0 0 24 24"><path d="M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8Z M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10Z M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z M19.1,17.7C17.9,18.9 16.2,19.6 14.5,19.9L15.9,18.5L14.5,17.1L13.1,18.5C12.7,18.4 12.4,18.4 12,18.4C11.6,18.4 11.3,18.4 10.9,18.5L9.5,17.1L8.1,18.5L9.5,19.9C7.8,19.6 6.1,18.9 4.9,17.7L6.3,16.3L4.9,14.9L3.5,16.3C3.2,14.6 2.9,12.9 3,11.2L4.4,11.2L4.4,9.2L3,9.2C2.9,7.5 3.2,5.8 3.5,4.1L4.9,5.5L6.3,4.1L4.9,2.7C6.1,1.5 7.8,0.8 9.5,0.5L8.1,1.9L9.5,3.3L10.9,1.9C11.3,2 11.6,2 12,2C12.4,2 12.7,2 13.1,1.9L14.5,3.3L15.9,1.9L14.5,0.5C16.2,0.8 17.9,1.5 19.1,2.7L17.7,4.1L19.1,5.5L20.5,4.1C20.8,5.8 21.1,7.5 21,9.2L19.6,9.2L19.6,11.2L21,11.2C21.1,12.9 20.8,14.6 20.5,16.3L19.1,14.9L17.7,16.3L19.1,17.7Z" /></symbol>
        <symbol id="icon-home" viewBox="0 0 24 24"><path d="M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z" /></symbol>
        <symbol id="icon-stats" viewBox="0 0 24 24"><path d="M22,21H2V3H4V19H6V10H10V19H12V6H16V19H18V14H22V21Z" /></symbol>
        <symbol id="icon-trophy" viewBox="0 0 24 24"><path d="M20.2,2H18.3C17.8,2 17.4,2.2 17.1,2.5L13.2,6.4L14.6,7.8L18.5,3.9C18.8,3.6 19,3.2 19,2.7V2H20.2M4,2H5.8C6.2,2 6.6,2.2 6.9,2.5L10.8,6.4L9.4,7.8L5.5,3.9C5.2,3.6 5,3.2 5,2.7V2H4M21,7C21,6.5 20.6,6.1 20.1,6.1H18.9C18.4,6.1 18,6.5 18,7V9.1L12.1,15L6,9V7C6,6.5 5.6,6.1 5.1,6.1H3.9C3.4,6.1 3,6.5 3,7V9C3,9.5 3.4,9.9 3.9,9.9H5.1C5.2,9.9 5.3,9.8 5.4,9.8L11.5,16L6,21.5C5.9,21.6 5.8,21.7 5.8,21.9C5.8,22.4 6.2,22.9 6.7,22.9H17.3C17.8,22.9 18.2,22.4 18.2,21.9C18.2,21.7 18.1,21.6 18,21.5L12.5,16L18.6,9.8C18.7,9.8 18.8,9.9 18.9,9.9H20.1C20.6,9.9 21,9.5 21,9V7Z" /></symbol>
        <symbol id="icon-sound-on" viewBox="0 0 24 24"><path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z" /></symbol>
        <symbol id="icon-sound-off" viewBox="0 0 24 24"><path d="M12,4L7,9H3V15H7L12,20V4M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12M19,12C19,13.82 18.1,15.44 16.84,16.41L18.28,17.85C19.8,16.57 21,14.48 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M2.27,1L1,3.27L4.73,7H3C2.45,7 2,7.45 2,8V16C2,16.55 2.45,17 3,17H7.73L14,23.27V17.27L19.73,23L21,21.73L2.27,1Z" /></symbol>
        <symbol id="icon-undo" viewBox="0 0 24 24"><path d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z" /></symbol>
        <symbol id="icon-hint" viewBox="0 0 24 24"><path d="M12,2A7,7 0 0,0 5,9C5,11.38 6.19,13.47 8,14.74V17A1,1 0 0,0 9,18H15A1,1 0 0,0 16,17V14.74C17.81,13.47 19,11.38 19,9A7,7 0 0,0 12,2M9,21A1,1 0 0,0 10,22H14A1,1 0 0,0 15,21V20H9V21Z" /></symbol>
        <symbol id="icon-magic" viewBox="0 0 24 24"><path d="M14.3,2.4L15.3,3.2L14.4,4.3L13.4,3.5L14.3,2.4M11.5,3.9L12.6,4.8L11.7,5.9L10.7,5.1L11.5,3.9M8.8,5.4L9.8,6.2L8.9,7.3L7.9,6.5L8.8,5.4M6.2,8.8L7.3,8.9L6.2,9.8L6.5,7.9L6.2,8.8M3.9,11.5L5.1,10.7L5.9,11.7L4.8,12.6L3.9,11.5M2.4,14.3L3.5,13.4L4.3,14.4L3.2,15.3L2.4,14.3M8.8,17.7L7.9,17.5L7.3,18.6L6.5,17.7L8.8,17.7M12,9C10.9,9 10,9.9 10,11C10,12.1 10.9,13 12,13C13.1,13 14,12.1 14,11C14,9.9 13.1,9 12,9M3,21.5L12.5,12L21.5,3L12,12.5L3,21.5Z" /></symbol>
        <symbol id="icon-menu" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></symbol>
        <symbol id="icon-coin" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,6A6,6 0 0,0 6,12A6,6 0 0,0 12,18A6,6 0 0,0 18,12A6,6 0 0,0 12,6M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16C11.69,16 11.39,15.96 11.11,15.89V18.83L10,18.3L9,18.79V15.87C8.36,15.56 8,14.85 8,14C8,12.9 8.9,12 10,12H14C14,10.9 13.1,10 12,10C10.9,10 10,10.9 10,12H8C8,9.79 9.79,8 12,8Z" /></symbol>
        <symbol id="icon-clock" viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z" /></symbol>
        <symbol id="icon-star" viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></symbol>
        <symbol id="icon-spade" class="suit-icon" viewBox="0 0 100 100"><path d="M50 0 L10 40 A20 20 0 0 0 50 70 A20 20 0 0 0 90 40 Z M50 65 L40 90 H60 Z"></path></symbol>
        <symbol id="icon-heart" class="suit-icon" viewBox="0 0 100 100"><path d="M90 40 C90 60, 50 90, 50 90 C50 90, 10 60, 10 40 A20 20 0 1 1 90 40 Z"></path></symbol>
        <symbol id="icon-diamond" class="suit-icon" viewBox="0 0 100 100"><path d="M50 0 L100 50 L50 100 L0 50 Z"></path></symbol>
        <symbol id="icon-club" class="suit-icon" viewBox="0 0 100 100"><circle cx="25" cy="50" r="20"/><circle cx="50" cy="25" r="20"/><circle cx="75" cy="50" r="20"/><path d="M50 45 L40 90 H60 Z"></path></symbol>
        <symbol id="icon-cheat" viewBox="0 0 24 24"><path d="M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></symbol>
    </svg>

    <script>
    // Объявляем глобальный объект, который будет хранить все наши модули
    const SolitaireGame = {};

    // --- МОДУЛЬ ЛОГИКИ ИГРЫ (Модель) ---
    (function(exports) {
        // ... (остается без изменений, так как логика корректна)
        const SUITS = { '♠': 'spade', '♥': 'heart', '♦': 'diamond', '♣': 'club' };
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const RANK_VALUES = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };

        exports.createDeck = function() {
            const deck = [];
            for (const suit in SUITS) {
                for (const rank of RANKS) {
                    deck.push({ 
                        id: `${rank}${suit}`,
                        suit, rank, value: RANK_VALUES[rank],
                        color: (suit === '♥' || suit === '♦') ? 'red' : 'black',
                        isFaceUp: false 
                    });
                }
            }
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        };
        exports.dealCards = function(deck) {
            const tableau = Array(7).fill(null).map(() => []);
            for (let i = 0; i < 7; i++) {
                for (let j = 0; j <= i; j++) {
                    const card = deck.pop();
                    if (j === i) card.isFaceUp = true;
                    tableau[i].push(card);
                }
            }
            return tableau;
        };
        exports.findValidMoves = function(gameState) {
            const moves = [];
            const { tableau, waste, foundations } = gameState;
            tableau.forEach((sourcePile, sourceIndex) => {
                for (let i = 0; i < sourcePile.length; i++) {
                    if (sourcePile[i].isFaceUp) {
                        const card = sourcePile[i];
                        tableau.forEach((destPile, destIndex) => {
                            if (sourceIndex !== destIndex) {
                                const topCard = destPile.length > 0 ? destPile[destPile.length - 1] : null;
                                if (!topCard && card.value === 13) moves.push({ from: { pile: 'tableau', index: sourceIndex, cardIndex: i }, to: { pile: 'tableau', index: destIndex } });
                                if (topCard && topCard.color !== card.color && topCard.value === card.value + 1) moves.push({ from: { pile: 'tableau', index: sourceIndex, cardIndex: i }, to: { pile: 'tableau', index: destIndex } });
                            }
                        });
                        if (i === sourcePile.length - 1) {
                            const foundationPile = foundations[card.suit];
                            if (foundationPile.length + 1 === card.value) moves.push({ from: { pile: 'tableau', index: sourceIndex, cardIndex: i }, to: { pile: 'foundation', suit: card.suit } });
                        }
                    }
                }
            });
            if (waste.length > 0) {
                const card = waste[waste.length - 1];
                tableau.forEach((destPile, destIndex) => {
                    const topCard = destPile.length > 0 ? destPile[destPile.length - 1] : null;
                    if (!topCard && card.value === 13) moves.push({ from: { pile: 'waste' }, to: { pile: 'tableau', index: destIndex } });
                    if (topCard && topCard.color !== card.color && topCard.value === card.value + 1) moves.push({ from: { pile: 'waste' }, to: { pile: 'tableau', index: destIndex } });
                });
                const foundationPile = foundations[card.suit];
                if (foundationPile.length + 1 === card.value) moves.push({ from: { pile: 'waste' }, to: { pile: 'foundation', suit: card.suit } });
            }
            return moves;
        };
        exports.checkWinCondition = function(gameState) {
            return Object.values(gameState.foundations).reduce((sum, pile) => sum + pile.length, 0) === 52;
        };

    })(SolitaireGame);

    // --- МОДУЛЬ ИНТЕРФЕЙСА (Представление) ---
    (function(exports) {
        // ... (большая часть переписана или обновлена)
        exports.buildScreens = function(container) {
            container.innerHTML = `
                <div id="main-menu-screen" class="screen"></div>
                <div id="settings-screen" class="screen"></div>
                <div id="stats-screen" class="screen"></div>
                <div id="achievements-screen" class="screen"></div>
                <div id="game-screen" class="screen"></div>`;
            const screens = {};
            container.querySelectorAll('.screen').forEach(el => screens[el.id.replace('-screen', '')] = el);
            screens['main-menu'].innerHTML = `
                <div class="title">КОСЫНКА<br>ПАСЬЯНС</div>
                <button data-action="play" class="main-btn"><svg><use href="#icon-play"></use></svg>ИГРАТЬ</button>
                <button data-action="show-settings" class="main-btn"><svg><use href="#icon-settings"></use></svg>НАСТРОЙКИ</button>
                <button data-action="show-cheats" class="main-btn"><svg><use href="#icon-cheat"></use></svg>ЧИТ-МЕНЮ</button>
                <div class="bottom-nav">
                    <button data-action="show-stats" class="main-btn"><svg><use href="#icon-stats"></use></svg></button>
                    <button data-action="show-achievements" class="main-btn"><svg><use href="#icon-trophy"></use></svg></button>
                </div>`;
            screens['settings'].innerHTML = `
                <div class="panel-title"><svg><use href="#icon-settings"></use></svg>НАСТРОЙКИ</div>
                <div class="panel-box">
                    <div class="setting-row">
                        <h3>Брать карты:</h3>
                        <button data-action="set-draw-count" data-value="1" class="toggle-btn">1</button>
                        <button data-action="set-draw-count" data-value="3" class="toggle-btn">3</button>
                    </div>
                    <div class="setting-row">
                         <h3>Рубашка:</h3>
                         <div class="card face-down back-1 card-back-selector" data-action="set-card-back" data-value="back-1"></div>
                         <div class="card face-down back-2 card-back-selector" data-action="set-card-back" data-value="back-2"></div>
                         <div class="card face-down back-3 card-back-selector" data-action="set-card-back" data-value="back-3"></div>
                    </div>
                    <div class="setting-row">
                        <button data-action="show-main-menu" class="main-btn">✓</button>
                        <button data-action="toggle-sound" class="main-btn"><svg class="sound-icon"><use href="#icon-sound-on"></use></svg></button>
                    </div>
                </div>`;
            screens['stats'].innerHTML = `
                <div class="panel-title"><svg><use href="#icon-stats"></use></svg>СТАТИСТИКА</div>
                <div id="stats-box" class="panel-box"></div>
                <div class="bottom-nav">
                    <button data-action="show-main-menu" class="main-btn"><svg><use href="#icon-home"></use></svg></button>
                    <button data-action="show-achievements" class="main-btn"><svg><use href="#icon-trophy"></use></svg></button>
                </div>`;
            screens['achievements'].innerHTML = `
                <div class="panel-title"><svg><use href="#icon-trophy"></use></svg>ДОСТИЖЕНИЯ</div>
                <div id="achievements-box" class="panel-box"></div>
                <div class="bottom-nav">
                    <button data-action="show-main-menu" class="main-btn"><svg><use href="#icon-home"></use></svg></button>
                    <button data-action="show-stats" class="main-btn"><svg><use href="#icon-stats"></use></svg></button>
                </div>`;
            screens['game'].innerHTML = `
                <div class="game-top-bar">
                    <span id="game-score"><svg><use href="#icon-coin"></use></svg>0</span>
                    <span id="game-timer"><svg><use href="#icon-clock"></use></svg>00:00</span>
                    <span id="game-moves"><svg><use href="#icon-star"></use></svg>0</span>
                </div>
                <div id="game-board">
                    <div class="top-row">
                        <div class="pile" id="stock-pile"><div class="pile-placeholder"></div></div>
                        <div class="pile" id="waste-pile"><div class="pile-placeholder"></div></div>
                        <div class="pile-spacer"></div>
                        ${['♠', '♥', '♦', '♣'].map((s) => `<div class="pile foundation-pile" data-suit="${s}"><div class="pile-placeholder foundation"></div></div>`).join('')}
                    </div>
                    <div class="bottom-row">
                        ${Array(7).fill(0).map((_, i) => `<div class="pile tableau-pile" data-index="${i}"><div class="pile-placeholder"></div></div>`).join('')}
                    </div>
                </div>
                <div class="game-bottom-bar">
                    <button data-action="show-main-menu" class="icon-btn"><svg><use href="#icon-menu"></use></svg></button>
                    <button data-action="get-hint" class="icon-btn"><svg><use href="#icon-hint"></use></svg><span class="badge" style="display: none;">1</span></button>
                    <button data-action="undo-move" class="icon-btn"><svg><use href="#icon-undo"></use></svg></button>
                    <button data-action="auto-complete" class="icon-btn"><svg><use href="#icon-magic"></use></svg></button>
                </div>`;
            return screens;
        };
        exports.navigateTo = function(screens, screenId) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (screens[screenId]) screens[screenId].classList.add('active');
        };
        exports.createCardElement = function(cardData, settings) {
            const cardEl = document.createElement('div');
            cardEl.id = `card-${cardData.id}`;
            cardEl.className = 'card';
            cardEl.dataset.id = cardData.id;
            exports.updateCardElement(cardEl, cardData, settings);
            return cardEl;
        };
        exports.updateCardElement = function(cardEl, cardData, settings) {
            cardEl.dataset.suit = cardData.suit;
            cardEl.dataset.rank = cardData.rank;
            cardEl.dataset.value = cardData.value;
            cardEl.classList.toggle('red', cardData.color === 'red');
            cardEl.classList.toggle('black', cardData.color === 'black');
            
            if (cardData.isFaceUp) {
                cardEl.classList.remove('face-down', 'back-1', 'back-2', 'back-3');
                if (!cardEl.innerHTML) { // Заполняем только если пусто, чтобы не перерисовывать svg
                    const suitId = { '♠': 'spade', '♥': 'heart', '♦': 'diamond', '♣': 'club' }[cardData.suit];
                    cardEl.innerHTML = `<span>${cardData.rank}</span><svg class="suit-icon"><use href="#icon-${suitId}"></use></svg>`;
                }
            } else {
                cardEl.innerHTML = '';
                cardEl.classList.add('face-down', settings.cardBack);
            }
        };
        // *** НОВАЯ ОПТИМИЗИРОВАННАЯ ФУНКЦИЯ ОБНОВЛЕНИЯ ПОЛЯ ***
        exports.updateGameBoard = function(gameState, settings) {
            // Сток и сброс - обновляем только верхнюю карту
            const stockPileEl = document.getElementById('stock-pile');
            const topStockCardData = gameState.stock.length > 0 ? gameState.stock[gameState.stock.length-1] : null;
            updateTopCard(stockPileEl, topStockCardData, settings);

            const wastePileEl = document.getElementById('waste-pile');
            const topWasteCardData = gameState.waste.length > 0 ? gameState.waste[gameState.waste.length-1] : null;
            updateTopCard(wastePileEl, topWasteCardData, settings);

            // Стопки "дома"
            for (const suit in gameState.foundations) {
                const pileEl = document.querySelector(`.foundation-pile[data-suit="${suit}"]`);
                const topCardData = gameState.foundations[suit].length > 0 ? gameState.foundations[suit].slice(-1)[0] : null;
                updateTopCard(pileEl, topCardData, settings);
            }

            // Игровые стопки (tableau) - самая сложная часть
            gameState.tableau.forEach((pileData, index) => {
                const pileEl = document.querySelector(`.tableau-pile[data-index="${index}"]`);
                // Удаляем лишние карты из DOM
                while (pileEl.children.length -1 > pileData.length) {
                    pileEl.lastChild.remove();
                }
                // Обновляем существующие и добавляем новые
                pileData.forEach((cardData, cardIndex) => {
                    let cardEl = pileEl.children[cardIndex + 1];
                    if (cardEl) { // Если карта уже есть в DOM, просто обновляем
                        if (cardEl.id !== `card-${cardData.id}`) { // Если карта не та, заменяем
                           cardEl.remove();
                           cardEl = exports.createCardElement(cardData, settings);
                           pileEl.appendChild(cardEl);
                        } else {
                           exports.updateCardElement(cardEl, cardData, settings);
                        }
                    } else { // Если карты нет, создаем и добавляем
                        cardEl = exports.createCardElement(cardData, settings);
                        pileEl.appendChild(cardEl);
                    }
                    cardEl.style.top = `${cardIndex * (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--card-height')) / 5)}px`;
                });
            });
        };
        // Вспомогательная функция для обновления одной карты в стопке
        function updateTopCard(pileEl, cardData, settings) {
            let cardEl = pileEl.querySelector('.card');
            if (cardData) {
                if (cardEl) {
                    if (cardEl.id !== `card-${cardData.id}`) {
                        exports.updateCardElement(cardEl, cardData, settings);
                        cardEl.id = `card-${cardData.id}`;
                    }
                } else {
                    cardEl = exports.createCardElement(cardData, settings);
                    pileEl.appendChild(cardEl);
                }
                cardEl.style.top = '0';
            } else if (cardEl) {
                cardEl.remove();
            }
        }
        exports.updateGameUI = function(gameState) {
             // ... (остается без изменений)
        };
        exports.updateSettingsUI = function(settings) {
            document.querySelectorAll('[data-action="set-draw-count"]').forEach(btn => btn.classList.toggle('active', parseInt(btn.dataset.value) === settings.drawCount));
            document.querySelectorAll('.card-back-selector').forEach(btn => btn.classList.toggle('active', btn.dataset.value === settings.cardBack));
            const soundBtn = document.querySelector('[data-action="toggle-sound"]');
            soundBtn.classList.toggle('active', settings.sound);
            soundBtn.querySelector('use').setAttribute('href', settings.sound ? '#icon-sound-on' : '#icon-sound-off');
        };
        // ... (остальные UI функции без изменений, они корректны)
        exports.clearHint = function() {
            document.querySelectorAll('.hint').forEach(el => el.classList.remove('hint'));
        };
        exports.showHint = function(move) {
            exports.clearHint();
            let fromEl, toEl;
            if (move.from.pile === 'waste') {
                fromEl = document.querySelector('#waste-pile .card:last-child');
            } else if (move.from.pile === 'tableau') {
                const sourcePile = document.querySelector(`.tableau-pile[data-index="${move.from.index}"]`);
                fromEl = sourcePile.children[move.from.cardIndex + 1];
            } else if (move.from.pile === 'stock') {
                 fromEl = document.querySelector('#stock-pile .card');
            }

            if (move.to.pile === 'tableau') {
                const destPile = document.querySelector(`.tableau-pile[data-index="${move.to.index}"]`);
                toEl = destPile.children[destPile.children.length - 1] || destPile.querySelector('.pile-placeholder');
            } else {
                toEl = document.querySelector(`.foundation-pile[data-suit="${move.to.suit}"] .pile-placeholder`);
            }
            if (fromEl) fromEl.classList.add('hint');
            if (toEl) toEl.classList.add('hint');
        };
        exports.showModal = function(title, bodyHTML) {
            const modal = document.getElementById('modal');
            modal.querySelector('.modal-title').textContent = title;
            modal.querySelector('.modal-body').innerHTML = bodyHTML;
            modal.classList.add('visible');
        };
        exports.hideModal = function() {
            document.getElementById('modal').classList.remove('visible');
        };

    })(SolitaireGame);
    
    // --- ГЛАВНЫЙ МОДУЛЬ ПРИЛОЖЕНИЯ (Контроллер) ---
    document.addEventListener('DOMContentLoaded', () => {
        const Game = SolitaireGame;
        const UI = SolitaireGame;
        
        const ANIMATION_DURATION = 300; // мс

        const App = {
            screens: {},
            settings: { drawCount: 1, sound: true, cardBack: 'back-1' },
            playerData: { totalScore: 0, totalMoves: 0, totalTime: 0 },
            gameState: null,
            gameTimer: null,
            history: [],
            selectedCardId: null,
            isAnimating: false,
            
            ACHIEVEMENTS: [
                { name: 'Новичок', score: 1000, icon: 'icon-heart' },
                { name: 'Игрок', score: 10000, icon: 'icon-diamond' },
                { name: 'Спец', score: 100000, icon: 'icon-star' },
                { name: 'Профи', score: 1000000, icon: 'icon-club' },
                { name: 'Мастер', score: 10000000, icon: 'icon-trophy' },
            ],
            SOUNDS: {
                click: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+'Pvv19/v18/vz+/v7+/vw==',
                place: 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAP///wA=',
                win: 'data:audio/wav;base64,UklGRkoAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YUYAAABx/3N/c39yf3J/cn9yf3J/cn9yf3J/cn9yf3J/c39zf3N/c39zf3N/c39x',
                error: 'data:audio/wav;base64,UklGRlYAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YVIAAAA9Pj8+Pz4/Pj8+Pz4/Pj8+Pz4/Pj8+Pj8+Pj8+Pj8+Pj8+Pz4/Pj8+Pz4/'
            }
        };

        function init() {
            App.screens = UI.buildScreens(document.getElementById('app-container'));
            loadData();
            attachEventListeners();
            UI.updateSettingsUI(App.settings);
            UI.navigateTo(App.screens, 'main-menu');
        }

        function playSound(name) {
            if (App.settings.sound) {
                const audio = new Audio(App.SOUNDS[name]);
                audio.play();
            }
        }
        
        function loadData() {
            const settings = localStorage.getItem('solitaire_settings_v2');
            if (settings) App.settings = { ...App.settings, ...JSON.parse(settings) };
            const playerData = localStorage.getItem('solitaire_playerData_v2');
            if (playerData) App.playerData = JSON.parse(playerData);
        }
        function saveData() {
            localStorage.setItem('solitaire_settings_v2', JSON.stringify(App.settings));
            localStorage.setItem('solitaire_playerData_v2', JSON.stringify(App.playerData));
        }
        
        function startGame() {
            clearInterval(App.gameTimer);
            const deck = Game.createDeck();
            const tableau = Game.dealCards(deck);
            App.gameState = {
                stock: deck, waste: [],
                foundations: {'♠': [], '♥': [], '♦': [], '♣': []},
                tableau: tableau,
                score: 0, moves: 0, time: 0,
            };
            App.history = []; App.selectedCardId = null;
            
            App.gameTimer = setInterval(() => {
                if (App.screens.game.classList.contains('active')) {
                    App.gameState.time++;
                    App.playerData.totalTime++;
                    UI.updateGameUI(App.gameState);
                }
            }, 1000);

            UI.updateGameBoard(App.gameState, App.settings);
            UI.updateGameUI(App.gameState);
            UI.navigateTo(App.screens, 'game');
        }

        function endGame(win) {
            clearInterval(App.gameTimer);
            if (win) {
                playSound('win');
                App.playerData.totalScore += App.gameState.score;
                UI.showModal('Победа!', `
                    <p>Поздравляем, вы выиграли!</p>
                    <p>Ваш счёт: ${App.gameState.score}</p>
                    <button data-action="play" class="main-btn">Играть снова</button>
                    <button data-action="show-main-menu" class="main-btn">Главное меню</button>
                `);
            }
            saveData();
        }
        
        function attachEventListeners() {
            document.body.addEventListener('click', e => {
                const actionTarget = e.target.closest('[data-action]');
                if (actionTarget) {
                    handleAction(actionTarget.dataset.action, actionTarget);
                } else {
                    handleBoardClick(e);
                }
            });
        }

        function handleAction(action, target) {
            UI.clearHint();
            switch (action) {
                case 'play': UI.hideModal(); startGame(); break;
                case 'show-main-menu': if(App.gameState && App.screens.game.classList.contains('active')) endGame(false); App.gameState = null; UI.hideModal(); UI.navigateTo(App.screens, 'main-menu'); break;
                case 'show-settings': UI.updateSettingsUI(App.settings); UI.navigateTo(App.screens, 'settings'); break;
                case 'show-stats': UI.renderStatsScreen(App.playerData); UI.navigateTo(App.screens, 'stats'); break;
                case 'show-achievements': UI.renderAchievementsScreen(App.playerData, App.ACHIEVEMENTS); UI.navigateTo(App.screens, 'achievements'); break;
                case 'set-draw-count': App.settings.drawCount = parseInt(target.dataset.value); UI.updateSettingsUI(App.settings); saveData(); break;
                case 'set-card-back': App.settings.cardBack = target.dataset.value; UI.updateSettingsUI(App.settings); saveData(); break;
                case 'toggle-sound': App.settings.sound = !App.settings.sound; UI.updateSettingsUI(App.settings); playSound('click'); saveData(); break;
                case 'undo-move': if(!App.isAnimating) undoMove(); break;
                case 'get-hint': if(!App.isAnimating) getHint(); break;
                case 'auto-complete': if(!App.isAnimating) autoComplete(); break;
                // Чит-меню
                case 'show-cheats': showCheatMenu(); break;
                case 'cheat-win': if(App.gameState) { cheatWin(); UI.hideModal(); } break;
                case 'cheat-score': cheatScore(); UI.hideModal(); break;
                case 'cheat-reveal': if(App.gameState) { cheatReveal(); UI.hideModal(); } break;
                case 'close-modal': UI.hideModal(); break;
            }
            if(action !== 'toggle-sound') playSound('click');
        }
        
        function handleBoardClick(e) {
            if (App.isAnimating || !App.screens.game.classList.contains('active')) return;
            UI.clearHint();
            const cardEl = e.target.closest('.card');
            const pileEl = e.target.closest('.pile');

            if (cardEl && !cardEl.classList.contains('face-down')) { // Клик по открытой карте
                if (App.selectedCardId === cardEl.dataset.id) { // Двойной клик (повторный)
                    const move = findMoveToFoundation(cardEl.dataset.id);
                    if (move) applyMove(move).then(() => App.selectedCardId = null);
                } else {
                    App.selectedCardId = cardEl.dataset.id;
                }
            } else if (pileEl) { // Клик по стопке
                if (pileEl.id === 'stock-pile') drawFromStock();
                else if (App.selectedCardId) {
                    const move = findMoveForSelection(pileEl);
                    if (move) applyMove(move);
                }
                App.selectedCardId = null;
            } else { // Клик мимо
                App.selectedCardId = null;
            }
            updateSelectionVisuals();
        }

        // Вспомогательные функции для поиска ходов
        function findMoveToFoundation(cardId) {
            const moves = Game.findValidMoves(App.gameState);
            return moves.find(m => {
                let sourceCard;
                if (m.from.pile === 'waste') sourceCard = App.gameState.waste.slice(-1)[0];
                else sourceCard = App.gameState.tableau[m.from.index][m.from.cardIndex];
                
                return sourceCard?.id === cardId && m.to.pile === 'foundation';
            });
        }
        function findMoveForSelection(targetPileEl) {
             const moves = Game.findValidMoves(App.gameState);
             return moves.find(m => {
                 let sourceCard;
                 if (m.from.pile === 'waste') sourceCard = App.gameState.waste.slice(-1)[0];
                 else sourceCard = App.gameState.tableau[m.from.index][m.from.cardIndex];
                 if (!sourceCard || sourceCard.id !== App.selectedCardId) return false;
                 
                 if (m.to.pile === 'foundation' && targetPileEl.dataset.suit === m.to.suit) return true;
                 if (m.to.pile === 'tableau' && targetPileEl.closest('.tableau-pile')?.dataset.index == m.to.index) return true;
                 return false;
             });
        }
        
        function updateSelectionVisuals() {
            document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
            if (App.selectedCardId) {
                const el = document.getElementById(`card-${App.selectedCardId}`);
                if (el) el.classList.add('selected');
            }
        }
        
        function saveHistory() {
            App.history.push(JSON.stringify(App.gameState));
            if(App.history.length > 20) App.history.shift();
        }
        function undoMove() {
            if (App.history.length === 0) return playSound('error');
            App.gameState = JSON.parse(App.history.pop());
            UI.updateGameBoard(App.gameState, App.settings);
            UI.updateGameUI(App.gameState);
            playSound('place');
        }
        
        function getHint() {
            const moves = Game.findValidMoves(App.gameState);
            if (moves.length > 0) {
                UI.showHint(moves[0]);
            } else {
                // Если ходов нет, проверим, можно ли перевернуть колоду
                if (App.gameState.stock.length > 0) {
                    UI.showHint({ from: { pile: 'stock' } });
                } else {
                    playSound('error');
                }
            }
        }
        
        async function autoComplete() {
            if(App.isAnimating) return;
            App.isAnimating = true;
            let moves = Game.findValidMoves(App.gameState);
            let foundationMove = moves.find(m => m.to.pile === 'foundation');
            while(foundationMove) {
                await applyMove(foundationMove, false);
                await new Promise(res => setTimeout(res, 100));
                moves = Game.findValidMoves(App.gameState);
                foundationMove = moves.find(m => m.to.pile === 'foundation');
            }
            App.isAnimating = false;
        }
        
        function drawFromStock() {
            saveHistory();
            const { stock, waste } = App.gameState;
            if (stock.length === 0 && waste.length > 0) {
                stock.push(...waste.reverse());
                waste.length = 0;
                stock.forEach(c => c.isFaceUp = false);
                App.gameState.score = Math.max(0, App.gameState.score - 100);
            } else {
                const count = Math.min(App.settings.drawCount, stock.length);
                for(let i = 0; i < count; i++){
                    const card = stock.pop();
                    card.isFaceUp = true;
                    waste.push(card);
                }
            }
            App.selectedCardId = null;
            UI.updateGameBoard(App.gameState, App.settings);
            UI.updateGameUI(App.gameState);
        }
        
        async function applyMove(move, doHistory=true) {
            if (App.isAnimating) return;
            App.isAnimating = true;
            if (doHistory) saveHistory();
            
            await animateCardMove(move);
            updateGameStateAfterMove(move);
            
            App.selectedCardId = null;
            playSound('place');
            UI.updateGameBoard(App.gameState, App.settings);
            UI.updateGameUI(App.gameState);
            
            if (Game.checkWinCondition(App.gameState)) {
                endGame(true);
            }
            App.isAnimating = false;
        }

        // Функция анимации вынесена отдельно
        async function animateCardMove(move) {
            const { from, to } = move;
            let fromEl, cardsToAnimate;

            if (from.pile === 'waste') {
                fromEl = document.querySelector('#waste-pile .card');
                cardsToAnimate = [fromEl];
            } else { // tableau
                const fromPileEl = document.querySelector(`.tableau-pile[data-index="${from.index}"]`);
                fromEl = fromPileEl.children[from.cardIndex + 1];
                cardsToAnimate = Array.from(fromPileEl.children).slice(from.cardIndex + 1);
            }
            if(!fromEl) return; // Если элемента нет, прекращаем
            const fromRect = fromEl.getBoundingClientRect();

            let toEl, toRect;
            if (to.pile === 'foundation') {
                toEl = document.querySelector(`.foundation-pile[data-suit="${to.suit}"]`);
            } else { // tableau
                toEl = document.querySelector(`.tableau-pile[data-index="${to.index}"]`);
            }
            const lastCardInToPile = toEl.querySelector('.card:last-child');
            toRect = (lastCardInToPile || toEl.querySelector('.pile-placeholder')).getBoundingClientRect();
            
            const animationLayer = document.getElementById('animation-layer');
            const flyingCards = cardsToAnimate.map((card, i) => {
                const flyingCard = card.cloneNode(true);
                flyingCard.classList.add('flying-card');
                flyingCard.style.position = 'fixed';
                flyingCard.style.left = `${card.getBoundingClientRect().left}px`;
                flyingCard.style.top = `${card.getBoundingClientRect().top}px`;
                flyingCard.style.transitionDuration = `${ANIMATION_DURATION}ms`;
                animationLayer.appendChild(flyingCard);
                return flyingCard;
            });
            
            await new Promise(res => requestAnimationFrame(res)); // Ждем следующего кадра для старта анимации
            
            flyingCards.forEach((flyingCard, i) => {
                const pileData = to.pile === 'tableau' ? App.gameState.tableau[to.index] : [];
                const yOffset = to.pile === 'tableau' ? (pileData.length + i) * (fromRect.height / 5) : 0;
                flyingCard.style.transform = `translate(${toRect.left - fromRect.left}px, ${toRect.top - fromRect.top + yOffset}px)`;
            });

            await new Promise(res => setTimeout(res, ANIMATION_DURATION));
            flyingCards.forEach(c => c.remove());
        }

        // Функция обновления состояния игры вынесена отдельно
        function updateGameStateAfterMove(move) {
            const { from, to } = move;
            let cardsToMove;

            if (from.pile === 'waste') {
                cardsToMove = [App.gameState.waste.pop()];
            } else { // tableau
                cardsToMove = App.gameState.tableau[from.index].splice(from.cardIndex);
            }

            if (to.pile === 'foundation') {
                App.gameState.foundations[to.suit].push(...cardsToMove);
                App.gameState.score += 10;
            } else { // tableau
                App.gameState.tableau[to.index].push(...cardsToMove);
                if (from.pile !== 'tableau') App.gameState.score += 5;
            }

            if (from.pile === 'tableau' && App.gameState.tableau[from.index].length > 0) {
                const topCard = App.gameState.tableau[from.index].slice(-1)[0];
                if (!topCard.isFaceUp) {
                    topCard.isFaceUp = true; App.gameState.score += 5;
                }
            }
            
            App.gameState.moves++; App.playerData.totalMoves++;
        }

        // --- ЧИТЫ ---
        function showCheatMenu() {
            const inGame = App.gameState !== null;
            const body = `
                <button data-action="cheat-win" class="main-btn" ${!inGame ? 'disabled' : ''}>Мгновенная победа</button>
                <button data-action="cheat-score" class="main-btn">+100,000 очков</button>
                <button data-action="cheat-reveal" class="main-btn" ${!inGame ? 'disabled' : ''}>Открыть все карты</button>
            `;
            UI.showModal('Чит-меню', body);
        }
        function cheatWin() {
            const allCards = [...App.gameState.stock, ...App.gameState.waste, ...App.gameState.tableau.flat()];
            App.gameState.stock = []; App.gameState.waste = []; App.gameState.tableau.forEach(p => p.length = 0);
            ['♠', '♥', '♦', '♣'].forEach(suit => {
                const suitCards = allCards.filter(c => c.suit === suit);
                suitCards.sort((a,b) => a.value - b.value);
                App.gameState.foundations[suit] = suitCards;
            });
            UI.updateGameBoard(App.gameState, App.settings);
            endGame(true);
        }
        function cheatScore() {
            App.playerData.totalScore += 100000;
            saveData();
            alert('+100,000 очков добавлено! Проверьте экран достижений.');
        }
        function cheatReveal() {
            App.gameState.tableau.forEach(pile => pile.forEach(card => card.isFaceUp = true));
            UI.updateGameBoard(App.gameState, App.settings);
        }
        
        init();
    });
    </script>
</body>
</html>
